栈-----stack
	栈是一个先入后出(FILO-First In Last Out)的有序列表。
	栈是元素的插入和删除只能在线性表的同一端进行的一种特殊线性表，即栈顶端。
	允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
	存放顺序：最先放入栈中元素在栈底，最后放入的元素在栈顶
	取走顺序：最后放入的元素最先删除，最先放入的元素最后删除
	方法：
		pop()-----------------------------拿走栈顶的元素，返回拿走的栈顶的元素
		push()----------------------------存取元素，永远存在栈顶端
		peek()----------------------------返回栈顶的元素但不取走
	应用：
		子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中	
		处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中
		表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)
		二叉树的遍历
		图形的深度优先(depth一first)搜索法
	中缀表达式--------常见运算表达式
		(3+4)*5-6
	前缀表达式--------波兰式
		运算符位于操作数前
		(3+4)*5-6------------->-*+3 4 5 6
		计算机求值：
			1. 从右至左扫描表达式
			2. 遇到数字时，将数字压入堆栈
			3. 遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算（注意栈顶元素在前，次顶元素在后），最后将计算结果存入栈
			4. 重复上述过程直到表达式最左端
			5. 最后运算的到的结果即为表达式的结果（即存在堆栈里的数据）
	后缀表达式--------逆波兰表达式
		运算符位于操作数之后
		(3+4)*5-6------------->3 4 + 5 * 6 -
		计算方法：
			1. 从左至右扫描表达式
			2. 遇到数字时，将数字压入堆栈
			3. 遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算（注意次顶元素在前，栈顶元素在后），最后将计算结果存入栈
			4. 重复上述过程直到表达式最左端
			5. 最后运算的到的结果即为表达式的结果（即存在堆栈里的数据）
	中缀表达式-------->后缀表达式
		1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2；
		2. 从左至右扫描中缀表达式；
		3. 遇到操作数时，将其压s2；
		4. 遇到运算符时，比较其与s1栈顶运算符的优先级：
			4.1 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
			4.2 若优先级比栈顶运算符的高，也将运算符压入s1；
			4.3 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；
		5. 遇到括号时：
			5.1 如果是左括号“(”，则直接压入s1
			5.2 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，最后将这一对括号丢弃
		6. 重复步骤2至5，直到表达式的最右边
		7. 将s1中剩余的运算符依次弹出并压入s2
		8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

递归-------Recursion
	说明：方法自己调用自己，每次调用时传入不同的变量	
	重要准则：	
		1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
		2. 方法的局部变量是独立的，不会相互影响
		3. 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据
		4. 递归必须向退出递归的条件逼近，否则就会无限递归，出现StackOverflowErroe
		5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕
	解决的实际应用问题：
		1. 数学问题：8皇后问题，阶乘问题，迷宫问题，球和篮子的问题等
		2. 算法：快排，归并排序，二分查找，分治算法等
		3. 将用栈解决的问题---->递归解决

	



